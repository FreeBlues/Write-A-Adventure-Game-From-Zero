#	从零开始写一个武侠冒险游戏-5-使用协程
##	 ---- 用协程实现控制权灵活切换

##	概述

因为我们的地图类是可以自己控制大小的, 在无意中用了一个比较大的数字 `500*500`后, 结果花了挺长时间来生成地图, 而在这段时间里, 屏幕黑乎乎的什么也不显示, 如果我们的游戏最终发布时也是这样, 那就太不专业了, 所以现在需要在地图生成过程中在屏幕上显示一些提示信息, 告诉用户还没有死机...

这个问题看似简单, 但是在 `Codea` 的程序架构下却没办法简单地实现, 需要用到 `Lua` 的另一项比较有趣的特性 `协程-coroutine`.

##	Codea 运行机制

我们知道, `Codea` 的运行机制是这样的:

-	`setup()` 只在程序启动时执行一次
- 	`draw()` 在程序执行完 `setup()` 后反复循环执行, 每秒执行 `60` 次
-  	`touched()` 跟 `draw()` 类似, 也是反复循环执行

简单说, 就是类似于这样的一个程序结构:

```
setup()

while true do
	...
	draw()
	touched(touch)
	...
end
```

而我们生成地图的函数只需要执行一次, 也就是说它们会被放在 `setup()` 中执行, 而在 `Codea` 中, `setup()` 没有执行完是不会去执行 `draw()` 的, 也就是说我们没办法在 `setup()` 阶段绘图, 如果我们的 `setup()` 执行的时间比较长的话, 我们就只能面对黑乎乎的屏幕傻等了.

怎么办呢? 幸运的是, `Lua` 还有 `协程-coroutine` 这个强大的特性, 利用它我们可以更灵活地控制程序的执行流程.

先稍微了解下协程.

##	协程 coroutine 的简单介绍

`Lua` 的`协程`全名为`协同式多线程`(`collaborative multithreading`). `Lua`为每个 `coroutine` 提供一个独立的运行线路。然而和多线程不同的地方就是，`coroutine` 只有在显式调用 `yield` 函数后才被挂起，再调用 `resume` 函数后恢复运行, 同一时间内只有一个协程正在运行.

`Lua` 将它的协程函数都放进了 `coroutine` 这个表里，其中主要的函数如下:

![表格图](https://static.oschina.net/uploads/img/201606/14224757_tdcN.png "表格图")

##	协程 coroutine 的使用示例

###	新建协程 coroutine.create()

使用 `coroutine.create(f)` 可以为指定函数 `f` 新建一个协程 `co`, 代码如下:

```
-- 先定义一个函数 f
function f ()
	print(os.time())
end

-- 为这个函数新建一个协程
co = coroutine.create(f)
```

通常协程的例子都是直接在 `coroutine.create()` 中使用一个匿名函数作为参数, 我们这里为了更容易理解, 专门定义了一个函数 `f`.

-	为一个函数新建协程的意义就在于我们可以通过协程来调用函数.

为什么要通过协程来调用函数呢? 因为如果我们直接调用函数, 那么从函数开始运行的那一刻起, 我们就只能被动地等待函数里的语句完全执行完后返回, 否则是没办法让函数在运行中`暂停/恢复`, 而如果是通过协程来调用的函数, 那么我们不仅可以让函数暂停在它内部的任意一条语句处, 还可以让函数随时从这个位置恢复运行. 

也就是说, 通过为一个函数新建协程, 我们对函数的控制粒度从函数级别精细到了语句级别.

###	协程状态 coroutine.status()

我们可以用 `coroutine.status(co)` 来查看当前协程 `co` 的状态

```
> coroutine.status(co)
suspended
>
```

看来新建的协程默认是被设置为 `挂起-suspended` 状态的, 需要手动恢复.

###	恢复协程 coroutine.resume()

执行 `coroutine.resume(co)`, 代码如下:

```
> coroutine.resume(co)
1465905122
true
> 
```
我们再查看一下协程的状态:

```
> coroutine.status(co)
dead
>
```

显示已经死掉了, 也就是说函数 `f` 已经执行完了. 

###	挂起协程 coroutine.yield()

有人就问了, 这个例子一下子就执行完了, 协程只是在最初被挂起了一次, 我们如何去手动控制它的`挂起/恢复`呢? 其实这个例子有些太简单, 没有很好地模拟出适合协程发挥作用的使用场景来, 设想一下, 我们有一个函数执行起来要花很多时间, 如果不使用协程的话, 我们就只能傻傻地等待它执行完. 

用了协程, 我们就可以在这个函数执行一段时间后, 执行一次 `coroutine.yield()` 让它暂停, 那么现在问题来了, 运行控制权如何转移? 这个函数执行了一半了, 控制权还在这个函数那里, 办法很简单, 就是把 `coroutine.yield()` 语句放在这个函数里边(当然, 我们也可以把它放在函数外面, 不过那是另外一个使用场景).

我们先把函数 `f` 改写成一个需要执行很长时间的函数, 然后把 `coroutine.yield()` 放在循环体中, 也就是让 `f` 每执行一次循环就自动挂起:

```
function f ()
	local k = 0
	for i=1,10000000 do
		k = k + i
		print(i)
		coroutine.yield()
	end
end
```

看看执行结果:

```
> co = coroutine.create(f)
> coroutine.status(co)
suspended
> coroutine.resume(co)                                                                                                                                                     2
true
> coroutine.status(co)
suspended
> coroutine.resume(co)
3
true
> coroutine.status(co)
suspended
> coroutine.resume(co)
4
true
> 
```

###	挂起协程 coroutine.yield()

有人就问了, 这个例子一下子就执行完了, 协程只是在最初被挂起了一次, 我们如何去手动控制它的`挂起/恢复`呢? 其实这个例子有些太简单, 没有很好地模拟出适合协程发挥作用的使用场景来, 设想一下, 我们有一个函数执行起来要花很多时间, 如果不使用协程的话, 我们就只能傻傻地等待它执行完. 

用了协程, 我们就可以在这个函数执行一段时间后, 执行一次 `coroutine.yield()` 让它暂停, 那么现在问题来了, 运行控制权如何转移? 这个函数执行了一半了, 控制权还在这个函数那里, 办法很简单, 就是把 `coroutine.yield()` 语句放在这个函数里边(当然, 我们也可以把它放在函数外面, 不过那是另外一个使用场景).

我们先把函数 `f` 改写成一个需要执行很长时间的函数, 然后把 `coroutine.yield()` 放在循环体中, 也就是让 `f` 每执行一次循环就自动挂起:

```
function f ()
	local k = 0
	for i=1,10000000 do
		k = k + i
		print(i)
		coroutine.yield()
	end
end
```

看看执行结果:

```
> co = coroutine.create(f)
> coroutine.status(co)
suspended
> coroutine.resume(co)                                                                                                                                                     2
true
> coroutine.status(co)
suspended
> coroutine.resume(co)
3
true
> coroutine.status(co)
suspended
> coroutine.resume(co)
4
true
> 
```

###	综合使用

很好, 完美地实现了我们的意图, 但是实际使用中我们肯定不会让程序这么频繁地 `暂停/恢复`, 一般会设置一个运行时间判断, 比如说执行 `1` 秒钟后暂停一次协程, 下面是改写后的代码:

```
time = os.time()
timeTick = 1

function f ()
	local k = 0
	for i=1,10000000 do
		k = k + i
		print(i)
		-- 如果运行时间超过 1 秒, 则暂停
		if (os.time() - time >= timeTick) then
			time = os.time()
			coroutine.yield()
		end
	end
end

co = coroutine.create(f)
coroutine.status(co)
coroutine.resume(co)
```
代码写好了, 但是运行起来表现有些不太对劲, 刚运行起来还正常, 但之后开始手动输入 `coroutine.resume(co)` 恢复时感觉还是跟之前的一样, 每个循环暂停一下, 认真分析才发现是因为我们手动输入的时间肯定要大于 `1` 秒, 所以每次都会暂停.

看来我们还需要修改一下代码, 那就再增加一个函数来负责自动按下恢复键, 然后把段代码放到一个无限循环中, 代码如下:

```
time = os.time()
timeTick = 1

function f ()
	local k = 0
	for i=1,10000000 do
		k = k + i
		-- print(i)
		-- 如果运行时间超过 timeTick 秒, 则暂停
		if (os.time() - time >= timeTick) then
			local str = string.format("Calc is %f%%", 100*i/10000000)
			print(str)
			time = os.time()
			coroutine.yield()
		end
	end
end

co = coroutine.create(f)

function autoResume()
	while true do
		coroutine.status(co)
		coroutine.resume(co)
	end
end

autoResume()
```

鉴于 `os.time()` 函数最小单位只能是 `1` 秒, 虽然使用 `1` 秒作为时间片有助于我们清楚地看到`暂停/恢复` 的过程, 但是如果我们想设置更小单位的时间片它就无能为力了, 所以后续改为使用 `os.clock()` 来计时, 它可以精确到毫秒级, 当然也可以设置为 `1` 秒, 把我们的时间片设置为 `0.1`, 代码如下:

```
time = os.clock()
timeTick = 0.1
print("timeTick is: ".. timeTick)

function f ()
	local k = 0
	for i=1,10000000 do
		k = k + i
		-- print(i)
		-- 如果运行时间超过 timeTick 秒, 则暂停
		if (os.clock() - time >= timeTick) then
			local str = string.format("Calc is %f%%", 100*i/10000000)
			print(str)
			time = os.clock()
			coroutine.yield()
		end
	end
end

co = coroutine.create(f)

function autoResume()
	while true do
		coroutine.status(co)
		coroutine.resume(co)
	end
end

autoResume()
```
执行记录如下:

```
Lua 5.3.2  Copyright (C) 1994-2015 Lua.org, PUC-Rio
timeTick is: 0.1
Calc is 0.556250%
Calc is 1.113390%
Calc is 1.671610%
Calc is 2.229500%
Calc is 2.787610%
Calc is 3.344670%
Calc is 3.902120%
Calc is 4.459460%
Calc is 5.017040%
...
```

好了, 关于协程, 我们已经基本了解了, 有了以上基础, 我们就接下来就要想办法把它放到 `Codea` 里去了. 

##	线程类及其使用

为方便使用, 以上面代码为基础将其改写为一个线程类, 具体代码如下:

```
Threads = class()

function Threads:init()
    self.threads = {}    
    self.time = os.clock()   
    self.timeTick = 0.1 
    self.worker = 1
    self.task = function() end
end

-- 切换点, 可放在准备暂停的函数内部, 一般选择放在多重循环的最里层, 这里耗时最多
function Threads:switchPoint()
    -- 切换线程，时间片耗尽，而工作还没有完成，挂起本线程，自动保存现场。
    if (os.clock() - self.time) >= self.timeTick then       
        self.time = os.clock()  
        -- 挂起当前协程 
        coroutine.yield()    
    end
end

-- 计算某个整数区间内所有整数之和，要在本函数中设置好挂起条件
function Threads:taskUnit()
	-- 可在此处执行用户的任务函数
	self.task()
        
	-- 切换点, 放在 self.task() 函数内部耗时较长的位置处, 以方便暂停
	self:switchPoint()      
end

-- 创建协程，分配任务，该函数执行一次即可。
function Threads:job ()
	local f = function () self:taskUnit() end
    -- 为 taskUnit() 函数创建协程。
    local co = coroutine.create(f)
    table.insert(self.threads, co)
end


-- 在 draw 中运行的分发器，借用 draw 的循环运行机制，调度所有线程的运行。
function Threads:dispatch()
    local n = #self.threads
    -- 线程表空了, 表示没有线程需要工作了。
    if n == 0 then return end   
    for i = 1, n do
    	-- 记录哪个线程在工作。
        self.worker = i    
        -- 恢复"coroutine"工作。
        local status = coroutine.resume(self.threads[i])
        -- 线程是否完成了他的工作？"coroutine"完成任务时，status是"false"。
        ---[[ 若完成则将该线程从调度表中删除, 同时返回。
        if not status then
            table.remove(self.threads, i)
            return
        end
        --]]
    end
end

-- 主程序框架
function setup()
    print("Threads...")
    
    myT = Threads()
    myT.task = needLongTime
    myT:job()
end

function needLongTime()
	local sum = 0
	for i=1,10000000 do
		sum = sum + i
		-- 在此插入切换点, 提供暂停控制
		myT:switchPoint() 
	end
end

function draw()
    background(0)
    
    myT:dispatch()
    
    sysInfo()
end

-- 显示FPS和内存使用情况
function sysInfo()
    pushMatrix()
    pushStyle()
    
    fill(255, 255, 255, 255)
    -- 根据 DeltaTime 计算 fps, 根据 collectgarbage("count") 计算内存占用
    local fps = math.floor(1/DeltaTime)
    local mem = math.floor(collectgarbage("count"))
    text("FPS: "..fps.."    Mem："..mem.." KB",650,740)
    popStyle()
    popMatrix()
end

```

使用方法也简单, 先在 `setup()` 中初始化, 再确定要创建协程的函数, 然后创建协程:

```
	...
	myT = Threads()
	myT.task = needLongTime
	myT:job()
	...
```

接着就是在 `draw()` 中运行分发器:

```
	...
	myT:dispatch()
	...
```

最后就是把切换点判断控制函数 `myT:switchPoint()` 插入到 `myT.task` 函数中的循环最里层:

```
	...
	for i=1,10000000 do
		sum = sum + i
		-- 在此插入切换点, 提供暂停控制
		myT:switchPoint() 
	end
	...
```

##	用线程类控制地图生成

剩下的工作就是把这个线程类用到地图生成类中, 保证在生成地图的同时还可以在屏幕上显示一些提示信息.

###	主要修改代码

经过分析, 地图生成类主要是 `createMapTable()` 函数花时间, 需要把它从 `init()` 函数中拿出来, 在主程序框架的 `setup()` 内用 `task` 来加载调用, 记得要把它封装成一个匿名函数的形式, 同时需要在它的多重循环内层放一个 `switchPoint()` 函数, 再写一个加载过程提示信息显示函数 ``, 具体如下:

```
function setup()
	...
	-- 初始化地图
	myMap = Maps()
	
	-- 使用线程类
	myT = Threads()
	myT.task = function () myMap:createMapTable() end
	myT:job()
	...
end

function draw()
	...
	myT:dispatch()
	...
	drawLoadingInfo()
	...
end	

-- 加载过程提示信息显示
function drawLoadingInfo()
    pushStyle()
    fontSize(60)
    fill(255,255,0)
    textMode(CENTER)
    text("程序加载中...",WIDTH/2,HEIGHT/2)
    popStyle() 
end
```

完整的代码因为太长, 就不在这里贴了, 可以来这里下载 [Github项目地址](https://github.com/FreeBlues/Write-A-Adventure-Game-From-Zero/blob/master/src/c05.lua).

好消息是我们的线程类起作用了, 可以在程序加载过程中显示提示信息, 坏消息是好像显示得有些乱.

原来我们之前的程序框架只考虑了一个场景: 游戏运行时, 没考虑运行之前的加载, 加载之前的游戏启动画面, 以及其他不同场景, 换句话说就是只有一个视图, 所以把所有的绘图代码都一股脑放在 `draw()` 里了, 现在我们多了一个加载场景, 都放在一起显然是不行了, 这就需要对主程序框架做一些修改, 让它支持多个视图互不影响, 这部分内容后续再详细讲解.

###	协程使用小结

本章我们利用协程实现了一个比较简单的功能, 但是讲解起来却占了不小的篇幅, 事实上协程很有用, 后续我们还可以让协程发挥更大的作用, 比如我们如果增加网络功能的话, 那么协程就是必不可少的工具了.

## 所有章节链接

[从零开始写一个武侠练功游戏-1-状态原型](http://my.oschina.net/freeblues/blog/687421)   
[从零开始写一个武侠练功游戏-2-帧动画](http://my.oschina.net/freeblues/blog/689399)  
[从零开始写一个武侠练功游戏-3-地图生成](http://my.oschina.net/freeblues/blog/690618)  
[从零开始写一个武侠冒险游戏-4-第一次整合](http://my.oschina.net/freeblues/blog/690718)  
[从零开始写一个武侠冒险游戏-5-使用协程]()

##	参考

本章参考了下面两篇文档的部分内容和代码, 对文档作者表示感谢.

[快速掌握Lua 5.3 —— Coroutines](http://blog.csdn.net/vermilliontear/article/details/50547852)  
[【深入Lua】理解Lua中最强大的特性-coroutine（协程）](http://my.oschina.net/wangxuanyihaha/blog/186401)

